# External Module

Developers can import existing (System)Verilog designs into Magia.
They can be instantiated as a normal `Module` does.

Common Use-cases are importing IP core such as:

- SRAM generated by Memory Compilers
- FPGA features such as PLL, SERDES, DDRx Controller, etc.
- Processor / Controller Cores.
- Verification IP such as SVA modules.

## Examples

```python
from magia import ExternalModule, Module

# Import a module from a file
NewModule = ExternalModule["path/to/file.sv", "ModuleName"]

# Import a module from a raw string
code = """module ModuleName #(parameter WIDTH=16, ...)(...); ... endmodule"""
NewModule = ExternalModule.from_code(code, "ModuleName")

# Specialize a module with parameters
# Module parameters in SV can be specialized by the constructor
module = NewModule(WIDTH=32, name="Module_with_32bit_width")


class Top(Module):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        ...
        submodule = NewModule(WIDTH=32, name="Module_with_32bit_width")
        submodule.instance("submodule", io={"input_a": self.io.input_a, "out": self.io.out})
        ...
```

## Syntax

`ExternalModule` is a metaclass that can be used to import a module from a file or a string,
which creates a new `Module` class that can be specialized and instantiated.

| Syntax                                            | Description                                                                                 |
|---------------------------------------------------|---------------------------------------------------------------------------------------------|
| `ExternalModule["path/to/file.sv", "ModuleName"]` | Import a module from a file and return a class of `ExternalModule`                          |
| `ExternalModule.from_code(code, "ModuleName")`    | Import a module from a raw string and return a class of `ExternalModule`                    |
| `ExternalModule[...](param1=...)`                 | Specialize a module with parameters. Override the parameter name if it exists in the module |
| `ExternalModule[...](param1=...).params`          | Get the current parameters of the specialized module                                        |
| `ExternalModule[...].default_params()`            | Get the default parameters of the module                                                    |
| `ExternalModule[...](...).io`                     | Access the I/O of the module                                                                |

## Limitations

- Directive and Macro are not supported.
- Inout port is not supported.
- `interface` is not supported.
- Ports with unpacked array are not supported. e.g. `input [WIDTH-1:0] a [0: PORT_COUNT-1];`
